
<html>
	<head>
		<style>
			`
			body{ 
					background-color: ivory; 
			}
			canvas{
					border:1px solid red;
			}
		</style>

	</head>
	<body>
		<h4>Drag one or more of the shapes</h4>
		<form>
        	<button id="close">Close</button>
        	<button id="join">Join</button>
		<textarea id="name" name="text area" rows="4" cols="50"></textarea>
        </form>
		<canvas id="canvas" width=1400 height=800></canvas>
        <div id="output"></div>
		<script>
	       		open();
			// get canvas related references
			let last = {};
			let radius = 25;
			var canvas=document.getElementById("canvas");
			var ctx=canvas.getContext("2d");
			var BB=canvas.getBoundingClientRect();
			var offsetX=BB.left;
			var offsetY=BB.top;
			var WIDTH = canvas.width;
			var HEIGHT = canvas.height;

			// drag related variables
			var dragok = false;
			var startX;
			var startY;

			// an array of objects that define different shapes
			var shapes={};
			// define 2 rectangles
			//shapes.push({id: 0, x:10,y:100,width:30,height:30,fill:"#444444",isDragging:false});
			//shapes.push({id: 1, x:80,y:100,width:30,height:30,fill:"#ff550d",isDragging:false});
			// define 2 circles
			//shapes.push({id: 2, x:150,y:100,text: "hello", r:50,fill:"#800080",isDragging:false});
			//shapes.push({id: 3, x:200, text: "hey", y:100,r:40,fill:"#0c64e8",isDragging:false});

			// listen for mouse events
			canvas.onmousedown = myDown;
			canvas.onmouseup = myUp;
			canvas.onmousemove = myMove;


			var background = new Image();
			background.src = "https://www.roomsketcher.com/wp-content/uploads/2017/11/RoomSketcher-Office-Floor-Plan-PID3529710-2D-bw-with-Labels.jpg";

			background.onload = function(){
    				ctx.drawImage(background,-130,-60, 1600, 950);   
			}

			// call to draw the scene
			drawsend();

			// draw a single rect
			function rect(r) {
				ctx.fillStyle=r.fill;
				ctx.fillRect(r.x,r.y,r.width,r.height);
			}

			function out(s) {

	     			console.log("2 PAUL THIS IS THE SHAPE:", s);
				if (!ws) {
					return;
				}
				console.log(s);
				ws.send(JSON.stringify(s));
			}

			// draw a single rect
			function circle(c) {
				ctx.fillStyle="lightgreen";
				ctx.beginPath();
				ctx.arc(c.x,c.y,radius,0,Math.PI*2);
				ctx.closePath();
				ctx.fill();
				ctx.fillStyle = "black"; 
  				var font = "bold " + radius+"px serif";
  				ctx.font = font;
 				ctx.textBaseline = "top";
  				ctx.fillText(c.id, c.x-(radius-9)/1 ,c.y-(radius-9)/2);
			}

			// clear the canvas
			function clear() {
				ctx.clearRect(0, 0, WIDTH, HEIGHT);
			}

			function solicit() {
				for(const property in shapes){
					ratelimit(out,property, 50);
				}
			}

			function drawsend() {
				clear();
    				ctx.drawImage(background,-130,-60, 1600, 950);   
				// redraw each shape in the shapes[] array
				for(const property in shapes){
					ratelimit(out,property, 50);
					// decide if the shape is a rect or circle
					// (it's a rect if it has a width property)
					if(shapes[property].width){
						rect(shapes[property]);
					}else{
						circle(shapes[property]);
					};
				}
			}

			// redraw the scene
			function draw() {
				clear();
    				ctx.drawImage(background,-130,-60, 1600, 950);   
				// redraw each shape in the shapes[] array
				for(const property in shapes){
					// decide if the shape is a rect or circle
					// (it's a rect if it has a width property)
					if(shapes[property].width){
						rect(shapes[property]);
					}else{
						circle(shapes[property]);
					};
				}
			}

			// handle mousedown events
			function myDown(e){

				// tell the browser we're handling this mouse event
				e.preventDefault();
				e.stopPropagation();

				// get the current mouse position
				var mx=parseInt(e.clientX-offsetX);
				var my=parseInt(e.clientY-offsetY);

				// test each shape to see if mouse is inside
				dragok=false;
				for(const property in shapes){
					var s=shapes[property];
					// decide if the shape is a rect or circle               
					if(s.width){
						// test if the mouse is inside this rect
						if(mx>s.x && mx<s.x+s.width && my>s.y && my<s.y+s.height){
							// if yes, set that rects isDragging=true
							dragok=true;
							s.isDragging=true;
						}
					}else{
						var dx=s.x-mx;
						var dy=s.y-my;
						// test if the mouse is inside this circle
						if(dx*dx+dy*dy<radius*radius){
							dragok=true;
							s.isDragging=true;
						}
					}
				}

				// save the current mouse position
				startX=mx;
				startY=my;
			}
		
			// handle mouseup events
			function myUp(e){
				// tell the browser we're handling this mouse event
				e.preventDefault();
				e.stopPropagation();

				// clear all the dragging flags
				dragok = false;
				for(const property in shapes){
					shapes[property].isDragging=false;
				}
			}


			// handle mouse moves
			function myMove(e){
				// if we're dragging anything...
				if (dragok){

					// tell the browser we're handling this mouse event
					e.preventDefault();
					e.stopPropagation();

					// get the current mouse position
					var mx=parseInt(e.clientX-offsetX);
					var my=parseInt(e.clientY-offsetY);

					// calculate the distance the mouse has moved
					// since the last mousemove
					var dx=mx-startX;
					var dy=my-startY;

					// move each rect that isDragging 
					// by the distance the mouse has moved
					// since the last mousemove
					for(const property in shapes){
						var s=shapes[property];
						if(s.isDragging){
							s.x+=dx;
							s.y+=dy;
						}
					}

					// redraw the scene with the new rect positions
					drawsend();

					// reset the starting mouse position for the next mousemove
					startX=mx;
					startY=my;
				}
			}


	    function join(name) {
	       shapes[name] = {id: name, x:200, y:100, isDragging: false};
		sleep(500).then(() => {
			drawsend();
		});
	    }

            function ratelimit(f, i, time) {
            	const now = +new Date();
            	if (!(i in last) || (now - last[i] > time)) {
           		last[i] = now;
            		f(shapes[i]);
            	}
            };

	    var output = document.getElementById("output");
            var ws;

            var print = function(message) {
            	var d = document.createElement("div");
            	d.textContent = message;
            	output.appendChild(d);
            };
            
	    document.getElementById("join").onclick = function(evt) {
		var name = document.getElementById("name").value; 
  		console.log(name); 				   
		join(name);
	        return false;
	    };

	   function sleep (time) {
  		return new Promise((resolve) => setTimeout(resolve, time));
	   }


	    function open() {
            	if (ws) {
            		return false;
            	}
            	ws = new WebSocket("ws:\/\/location.hostname:location.port\/echo");
            	ws.onopen = function(evt) {
            		print("OPEN");
            	}
            	ws.onclose = function(evt) {
            		print("CLOSE");
            		ws = null;
            	}
            	ws.onmessage = function(evt) {
			var data = JSON.parse(evt.data);
			if (data.message == "solicit"){
				solicit();
				return;
			}
			if (shapes[data.id].isDragging){
				return
			}
			if (!(data.id in shapes)) {
				shapes[data.id] = data;
			}
			var s = shapes[data.id];
			s.x = data.x;
			s.y = data.y;
			draw();

            	}
            	ws.onerror = function(evt) {
            		print("ERROR: " + evt.data);
            	}
            };

		</script>
	</body>
</html>
